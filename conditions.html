<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stock Prediction Visualization Conditions</title>
    
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8f9fa;
            color: #212529;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .header h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .header p {
            color: #6c757d;
            font-size: 14px;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .legend-line {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        .legend-stock-a { background: #007bff; }
        .legend-stock-b { background: #fd7e14; }
        .legend-historical { background: #6c757d; }

        .visualization-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 20px;
            height: 80vh;
        }

        .condition-panel {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }

        .condition-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 2px solid #e9ecef;
        }

        .condition-description {
            font-size: 12px;
            color: #6c757d;
            text-align: center;
            margin-bottom: 15px;
        }

        .chart-container {
            flex: 1;
            display: flex;
            justify-content: center;
        }

        .chart-svg {
            border: 1px solid #e9ecef;
            border-radius: 4px;
            background: #ffffff;
        }

        /* Condition-specific styling */
        .condition-1 .condition-title {
            color: #007bff;
            border-bottom-color: #007bff;
        }

        .condition-2 .condition-title {
            color: #dc3545;
            border-bottom-color: #dc3545;
        }

        .condition-3 .condition-title {
            color: #ffc107;
            border-bottom-color: #ffc107;
        }

        .condition-4 .condition-title {
            color: #28a745;
            border-bottom-color: #28a745;
        }

        /* Chart styling */
        .axis {
            font-size: 10px;
        }

        .axis path,
        .axis line {
            fill: none;
            stroke: #ccc;
            shape-rendering: crispEdges;
        }

        .grid line {
            stroke: #f0f0f0;
            stroke-width: 1px;
        }

        .grid path {
            stroke-width: 0;
        }

        .historical-line {
            fill: none;
            stroke: #6c757d;
            stroke-width: 2;
        }

        .prediction-line {
            fill: none;
            stroke-width: 2;
            opacity: 0.4;
        }

        .aggregated-line {
            fill: none;
            stroke-width: 2;
            opacity: 1;
        }

        .stock-a-line {
            stroke: #007bff;
        }

        .stock-b-line {
            stroke: #fd7e14;
        }

        .hover-overlay {
            fill: transparent;
            cursor: pointer;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .visualization-grid {
                grid-template-columns: 1fr;
                grid-template-rows: repeat(4, 350px);
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Stock Prediction Visualization Conditions</h1>
            <p>Comparing four different methods of presenting prediction uncertainty</p>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-line legend-historical"></div>
                <span>Historical Data</span>
            </div>
            <div class="legend-item">
                <div class="legend-line legend-stock-a"></div>
                <span>Stock A</span>
            </div>
            <div class="legend-item">
                <div class="legend-line legend-stock-b"></div>
                <span>Stock B</span>
            </div>
        </div>

        <div class="visualization-grid">
            <!-- Condition 1: Aggregated Only -->
            <div class="condition-panel condition-1">
                <div class="condition-title">Condition 1: Aggregated Only</div>
                <div class="condition-description">Shows only aggregated prediction lines</div>
                <div class="chart-container">
                    <svg id="chart-1" class="chart-svg" width="400" height="300"></svg>
                </div>
            </div>

            <!-- Condition 2: Alternative Only -->
            <div class="condition-panel condition-2">
                <div class="condition-title">Condition 2: Alternative Only</div>
                <div class="condition-description">Shows only individual alternative predictions</div>
                <div class="chart-container">
                    <svg id="chart-2" class="chart-svg" width="400" height="300"></svg>
                </div>
            </div>

            <!-- Condition 3: Aggregate + Alternative -->
            <div class="condition-panel condition-3">
                <div class="condition-title">Condition 3: Aggregate + Alternative</div>
                <div class="condition-description">Shows both aggregated and alternative predictions</div>
                <div class="chart-container">
                    <svg id="chart-3" class="chart-svg" width="400" height="300"></svg>
                </div>
            </div>

            <!-- Condition 4: Hover on Detail -->
            <div class="condition-panel condition-4">
                <div class="condition-title">Condition 4: Hover on Detail</div>
                <div class="condition-description">Aggregated by default, hover to reveal alternatives</div>
                <div class="chart-container">
                    <svg id="chart-4" class="chart-svg" width="400" height="300"></svg>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const config = {
            width: 400,
            height: 300,
            margin: { top: 20, right: 20, bottom: 40, left: 50 },
            colors: {
                historical: '#6c757d',
                stockA: '#007bff',
                stockB: '#fd7e14'
            }
        };

        // Global variables for data
        let stockData = {};
        let globalYScale = null;
        let sampledScenarios = [];
        let realTimeAggregated = {};

        // Load and process data
        d3.json('synthetic_stock_data.json').then(function(rawData) {
            // Process the data
            processData(rawData.data);
            
            // Create all visualizations
            createAllCharts();
        }).catch(function(error) {
            console.error('Error loading data:', error);
            // Add error message to page
            document.querySelector('.visualization-grid').innerHTML = 
                '<div style="grid-column: 1/-1; text-align: center; color: red;">Error loading data. Please ensure synthetic_stock_data.json is available.</div>';
        });

        function processData(data) {
            // Separate data by stock
            const stockA = data.filter(d => d.stock === 'A');
            const stockB = data.filter(d => d.stock === 'B');

            // Get all available scenarios from prediction data
            const allScenarios = [...new Set(data
                .filter(d => d.series === 'prediction')
                .map(d => d.scenario)
            )];
            
            console.log('Available scenarios:', allScenarios);
            
            // Random sample 5 scenarios out of 10
            sampledScenarios = sampleScenarios(allScenarios, 5);
            console.log('Sampled scenarios:', sampledScenarios);

            // Process each stock
            stockData.A = processStockData(stockA);
            stockData.B = processStockData(stockB);
            
            // Calculate real-time aggregated data from sampled scenarios
            calculateRealTimeAggregation(data);

            // Debug log
            console.log('Processed data:', stockData);
            console.log('Real-time aggregated data points:', realTimeAggregated.A?.length || 0);
            console.log('Sample real-time aggregated data:', realTimeAggregated.A?.slice(0, 5) || []);

            // Calculate global Y scale
            const allValues = [];
            Object.values(stockData).forEach(stock => {
                stock.historical.forEach(d => allValues.push(d.price));
                stock.alternatives.forEach(d => allValues.push(d.price));
            });
            
            // Include real-time aggregated values in scale calculation
            Object.values(realTimeAggregated).forEach(aggregatedData => {
                if (aggregatedData) {
                    aggregatedData.forEach(d => allValues.push(d.price));
                }
            });

            // Fixed y-scale range from 90 to 110
            globalYScale = [90, 110];
        }
        
        // Fisher-Yates shuffle for random sampling
        function sampleScenarios(scenarios, sampleSize) {
            const scenariosCopy = [...scenarios];
            
            // Fisher-Yates shuffle
            for (let i = scenariosCopy.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [scenariosCopy[i], scenariosCopy[j]] = [scenariosCopy[j], scenariosCopy[i]];
            }
            
            return scenariosCopy.slice(0, sampleSize);
        }
        
        // Calculate real-time aggregation from sampled scenarios
        function calculateRealTimeAggregation(data) {
            ['A', 'B'].forEach(stock => {
                // Filter prediction data for this stock and sampled scenarios
                const predictionData = data.filter(d => 
                    d.stock === stock && 
                    d.series === 'prediction' && 
                    sampledScenarios.includes(d.scenario)
                );
                
                // Group by date
                const groupedByDate = {};
                predictionData.forEach(item => {
                    if (!groupedByDate[item.date]) {
                        groupedByDate[item.date] = [];
                    }
                    groupedByDate[item.date].push(item.price);
                });
                
                // Calculate mean for each date
                const aggregatedData = [];
                Object.keys(groupedByDate).sort().forEach(date => {
                    const prices = groupedByDate[date];
                    const meanPrice = prices.reduce((sum, price) => sum + price, 0) / prices.length;
                    aggregatedData.push({
                        date: new Date(date),
                        price: meanPrice
                    });
                });
                
                realTimeAggregated[stock] = aggregatedData;
                console.log(`Real-time aggregation for stock ${stock}:`, aggregatedData.length, 'data points');
            });
        }

        function processStockData(stockData) {
            const historical = stockData
                .filter(d => d.series === 'historical')
                .map(d => ({ date: new Date(d.date), price: d.price }))
                .sort((a, b) => a.date - b.date);

            // Filter alternatives to only include sampled scenarios
            const alternatives = stockData
                .filter(d => d.series === 'prediction' && 
                           d.scenario && 
                           sampledScenarios.includes(d.scenario))
                .map(d => ({ scenario: d.scenario, date: new Date(d.date), price: d.price }))
                .sort((a, b) => a.date - b.date);

            return {
                historical,
                alternatives
            };
        }

        function createAllCharts() {
            // Condition 1: Aggregated Only
            createChart('chart-1', { showAggregated: true, showAlternatives: false, hover: false });

            // Condition 2: Alternative Only
            createChart('chart-2', { showAggregated: false, showAlternatives: true, hover: false });

            // Condition 3: Aggregate + Alternative
            createChart('chart-3', { showAggregated: true, showAlternatives: true, hover: false });

            // Condition 4: Hover on Detail
            createChart('chart-4', { showAggregated: true, showAlternatives: true, hover: true });
        }

        function createChart(svgId, options) {
            const svg = d3.select(`#${svgId}`);
            const margin = config.margin;
            const width = config.width - margin.left - margin.right;
            const height = config.height - margin.top - margin.bottom;

            // Clear existing content
            svg.selectAll("*").remove();

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Scales - extend x-axis to 6/30
            const allDates = [
                ...stockData.A.historical.map(d => d.date),
                ...stockData.B.historical.map(d => d.date),
                ...(realTimeAggregated.A ? realTimeAggregated.A.map(d => d.date) : []),
                ...(realTimeAggregated.B ? realTimeAggregated.B.map(d => d.date) : [])
            ];

            const xScale = d3.scaleTime()
                .domain([d3.min(allDates), new Date('2025-06-30')])
                .range([0, width]);

            const yScale = d3.scaleLinear()
                .domain(globalYScale)
                .range([height, 0]);

            // Add grid
            g.append("g")
                .attr("class", "grid")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale)
                    .tickSize(-height)
                    .tickFormat("")
                );

            g.append("g")
                .attr("class", "grid")
                .call(d3.axisLeft(yScale)
                    .tickSize(-width)
                    .tickFormat("")
                );

            // Add axes
            g.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale).tickFormat(d3.timeFormat("%m/%d")));

            g.append("g")
                .attr("class", "axis")
                .call(d3.axisLeft(yScale));

            // Draw historical lines for both stocks
            const line = d3.line()
                .x(d => xScale(d.date))
                .y(d => yScale(d.price))
                .curve(d3.curveMonotoneX);

            // Stock A historical
            g.append("path")
                .datum(stockData.A.historical)
                .attr("class", "historical-line")
                .attr("d", line);

            // Stock B historical  
            g.append("path")
                .datum(stockData.B.historical)
                .attr("class", "historical-line")
                .attr("d", line);

            // Removed all dots as requested

            // Prediction lines and interactions
            const predictionGroup = g.append("g").attr("class", "predictions");

            // Real-time aggregated predictions - calculated from 5 sampled scenarios
            if (options.showAggregated) {
                ['A', 'B'].forEach((stock, i) => {
                    const color = i === 0 ? config.colors.stockA : config.colors.stockB;
                    const lastHistorical = stockData[stock].historical[stockData[stock].historical.length - 1];
                    
                    if (realTimeAggregated[stock] && realTimeAggregated[stock].length > 0) {
                        // Create continuous path through all real-time aggregated data points
                        const fullAggregatedData = [lastHistorical, ...realTimeAggregated[stock]];
                        
                        predictionGroup.append("path")
                            .datum(fullAggregatedData)
                            .attr("class", `aggregated-line real-time-aggregated stock-${stock.toLowerCase()}-line`)
                            .attr("stroke", color)
                            .attr("d", line);
                            
                        console.log(`Plotted real-time aggregated line for stock ${stock} with ${realTimeAggregated[stock].length} points`);
                        
                        // Add hover zone for this aggregated line (only in hover condition)
                        if (options.hover) {
                            predictionGroup.append("path")
                                .datum(fullAggregatedData)
                                .attr("class", `hover-zone-${stock.toLowerCase()}`)
                                .attr("fill", "none")
                                .attr("stroke", "transparent")
                                .attr("stroke-width", 15) // Wide invisible stroke for easier hovering
                                .attr("d", line)
                                .style("cursor", "pointer");
                        }
                    }
                });
            }

            // Alternative predictions - plot only the 5 sampled scenarios
            if (options.showAlternatives) {
                // Create separate groups for each stock's alternatives
                const alternativesGroupA = predictionGroup.append("g")
                    .attr("class", "alternatives-group-a")
                    .style("opacity", options.hover ? 0 : 1);
                    
                const alternativesGroupB = predictionGroup.append("g")
                    .attr("class", "alternatives-group-b")
                    .style("opacity", options.hover ? 0 : 1);

                ['A', 'B'].forEach((stock, i) => {
                    const color = i === 0 ? config.colors.stockA : config.colors.stockB;
                    const lastHistorical = stockData[stock].historical[stockData[stock].historical.length - 1];
                    const currentAlternativesGroup = stock === 'A' ? alternativesGroupA : alternativesGroupB;
                    
                    // Group alternatives by scenario (should only include sampled scenarios)
                    const scenarios = {};
                    stockData[stock].alternatives.forEach(alt => {
                        if (!scenarios[alt.scenario]) {
                            scenarios[alt.scenario] = [];
                        }
                        scenarios[alt.scenario].push(alt);
                    });
                    
                    console.log(`Stock ${stock} alternative scenarios:`, Object.keys(scenarios));
                    console.log(`Expected sampled scenarios:`, sampledScenarios);
                    
                    // Create a line for each sampled scenario
                    Object.entries(scenarios).forEach(([scenarioName, scenarioData], scenarioIndex) => {
                        if (scenarioData.length > 0) {
                            const fullScenarioData = [lastHistorical, ...scenarioData];
                            
                            currentAlternativesGroup.append("path")
                                .datum(fullScenarioData)
                                .attr("class", `prediction-line alternative-line scenario-${scenarioIndex} stock-${stock.toLowerCase()}-line`)
                                .attr("fill", "none")
                                .attr("stroke", color)
                                .attr("stroke-width", 1.5)
                                .attr("opacity", 0.4)
                                .attr("d", line);
                                
                            console.log(`Plotted alternative scenario ${scenarioName} for stock ${stock} with ${scenarioData.length} points`);
                        }
                    });
                });

                // Add hover interactions for condition 4 (hover on specific lines)
                if (options.hover) {
                    // Stock A hover zone interactions
                    d3.select(`#${svgId}`).select('.hover-zone-a')
                        .on("mouseenter", function() {
                            alternativesGroupA.transition()
                                .duration(200)
                                .style("opacity", 1);
                        })
                        .on("mouseleave", function() {
                            alternativesGroupA.transition()
                                .duration(200)
                                .style("opacity", 0);
                        });
                    
                    // Stock B hover zone interactions
                    d3.select(`#${svgId}`).select('.hover-zone-b')
                        .on("mouseenter", function() {
                            alternativesGroupB.transition()
                                .duration(200)
                                .style("opacity", 1);
                        })
                        .on("mouseleave", function() {
                            alternativesGroupB.transition()
                                .duration(200)
                                .style("opacity", 0);
                        });
                }
            }
        }
    </script>
</body>
</html>