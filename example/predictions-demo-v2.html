<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prediction Visualization Cases - All 15 Combinations</title>
    
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- Custom Styles -->
    <link href="styles.css" rel="stylesheet" type="text/css" />
</head>
<body>
    <div class="container">
        <header>
            <h1>Prediction Visualization Cases</h1>
            <p class="subtitle">Hover over each chart to reveal alternative predictions</p>
        </header>
        
        <div class="legend-container">
            <div class="legend-item">
                <div class="legend-line historical"></div>
                <span>Historical Data</span>
            </div>
            <div class="legend-item">
                <div class="legend-line aggregation"></div>
                <span>Aggregated Prediction</span>
            </div>
            <div class="legend-item">
                <div class="legend-line alternatives"></div>
                <span>Alternative Predictions (on hover)</span>
            </div>
        </div>
        
        <div class="grid-container">
            <div class="column-headers">
                <div class="spacer"></div>
                <div class="column-header increase">Increase</div>
                <div class="column-header decrease">Decrease</div>
                <div class="column-header stable">Stable</div>
            </div>
            
            <div class="grid-with-labels">
                <div class="row-labels">
                    <div class="row-label">Agreement</div>
                    <div class="row-label">Polarization</div>
                    <div class="row-label">Risk of Loss</div>
                    <div class="row-label">Chance of Gain</div>
                    <div class="row-label">Ambiguous Spread</div>
                </div>
                
                <div class="charts-grid" id="charts-container">
                    <!-- Charts will be dynamically generated here -->
                </div>
            </div>
        </div>
        
        <div class="info-panel">
            <h3>Understanding the Visualization</h3>
            <ul>
                <li><strong>Columns:</strong> Aggregation trends (Increase, Decrease, Stable)</li>
                <li><strong>Rows:</strong> Alternative patterns (Agreement, Polarization, Risk of Loss, Chance of Gain, Ambiguous Spread)</li>
                <li><strong>Interaction:</strong> Hover over any chart to see the alternative predictions with varying confidence levels</li>
                <li><strong>Note:</strong> All charts share the same Y-axis scale for easy comparison</li>
            </ul>
        </div>
    </div>
    
    <!-- Main Visualization Script -->
    <script>
        // Configuration
        const config = {
            chartWidth: 260,
            chartHeight: 180,
            margin: { top: 20, right: 20, bottom: 30, left: 40 },
            colors: {
                historical: '#22c55e',
                aggregation: '#a855f7',
                alternatives: '#a855f7',
                grid: '#e5e7eb'
            },
            alternativeOpacity: 0.5
        };

        // Pattern and trend labels
        const patternLabels = {
            'agreement': 'Agreement',
            'polarization': 'Polarization',
            'risk_of_loss': 'Risk of Loss',
            'chance_of_gain': 'Chance of Gain',
            'ambiguous_spread': 'Ambiguous Spread'
        };

        const trendLabels = {
            'increase': 'Increase',
            'decrease': 'Decrease',
            'stable': 'Stable'
        };

        // Create chart function
        function createChart(container, caseData, globalYScale) {
            const width = config.chartWidth;
            const height = config.chartHeight;
            const margin = config.margin;
            
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;
            
            // Create chart container
            const chartDiv = d3.select(container)
                .append('div')
                .attr('class', 'chart-wrapper')
                .attr('data-trend', caseData.trend)
                .attr('data-pattern', caseData.pattern)
                .attr('data-title', `${trendLabels[caseData.trend]} - ${patternLabels[caseData.pattern]}`);
            
            // Create SVG
            const svg = chartDiv.append('svg')
                .attr('width', width)
                .attr('height', height)
                .attr('class', 'chart-svg');
            
            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Prepare data
            const historicalData = caseData.historical;
            const currentPrice = historicalData[historicalData.length - 1].value;
            const aggregationValue = caseData.aggregation;
            const alternatives = caseData.alternatives;
            
            // Create X scale
            const xScale = d3.scaleLinear()
                .domain([0, historicalData.length])
                .range([0, chartWidth]);
            
            // Use global Y scale
            const yScale = d3.scaleLinear()
                .domain(globalYScale)
                .range([chartHeight, 0]);
            
            // Add grid
            g.append('g')
                .attr('class', 'grid grid-x')
                .attr('transform', `translate(0,${chartHeight})`)
                .call(d3.axisBottom(xScale)
                    .tickSize(-chartHeight)
                    .tickFormat('')
                    .ticks(5))
                .style('stroke-dasharray', '2,2')
                .style('opacity', 0.3);
            
            g.append('g')
                .attr('class', 'grid grid-y')
                .call(d3.axisLeft(yScale)
                    .tickSize(-chartWidth)
                    .tickFormat('')
                    .ticks(5))
                .style('stroke-dasharray', '2,2')
                .style('opacity', 0.3);
            
            // Draw historical line
            const line = d3.line()
                .x((d, i) => xScale(i))
                .y(d => yScale(d.value))
                .curve(d3.curveMonotoneX);
            
            g.append('path')
                .datum(historicalData)
                .attr('class', 'historical-line')
                .attr('fill', 'none')
                .attr('stroke', config.colors.historical)
                .attr('stroke-width', 2)
                .attr('d', line);
            
            // Add historical dots (last 3)
            g.selectAll('.historical-dot')
                .data(historicalData.slice(-3))
                .enter().append('circle')
                .attr('class', 'historical-dot')
                .attr('cx', (d, i) => xScale(historicalData.length - 3 + i))
                .attr('cy', d => yScale(d.value))
                .attr('r', 3)
                .attr('fill', config.colors.historical);
            
            // Add current point
            g.append('circle')
                .attr('class', 'current-dot')
                .attr('cx', xScale(historicalData.length - 1))
                .attr('cy', yScale(currentPrice))
                .attr('r', 4)
                .attr('fill', config.colors.historical)
                .attr('stroke', 'white')
                .attr('stroke-width', 2);
            
            // Draw aggregation prediction line
            const predictionX = historicalData.length;
            
            g.append('line')
                .attr('class', 'aggregation-line')
                .attr('x1', xScale(historicalData.length - 1))
                .attr('y1', yScale(currentPrice))
                .attr('x2', xScale(predictionX))
                .attr('y2', yScale(aggregationValue))
                .attr('stroke', config.colors.aggregation)
                .attr('stroke-width', 2.5)
                .attr('stroke-dasharray', '5,3');
            
            g.append('circle')
                .attr('class', 'aggregation-dot')
                .attr('cx', xScale(predictionX))
                .attr('cy', yScale(aggregationValue))
                .attr('r', 5)
                .attr('fill', config.colors.aggregation)
                .attr('stroke', 'white')
                .attr('stroke-width', 2);
            
            // Create alternatives group (hidden by default)
            const alternativesGroup = g.append('g')
                .attr('class', 'alternatives-group')
                .style('opacity', 0);
            
            // Draw alternative prediction lines
            alternatives.forEach((value, i) => {
                alternativesGroup.append('line')
                    .attr('class', `alternative-line alternative-${i}`)
                    .attr('x1', xScale(historicalData.length - 1))
                    .attr('y1', yScale(currentPrice))
                    .attr('x2', xScale(predictionX))
                    .attr('y2', yScale(value))
                    .attr('stroke', config.colors.alternatives)
                    .attr('stroke-width', 1.5)
                    .attr('stroke-dasharray', '3,2')
                    .attr('opacity', config.alternativeOpacity);
                
                alternativesGroup.append('circle')
                    .attr('class', `alternative-dot alternative-${i}`)
                    .attr('cx', xScale(predictionX))
                    .attr('cy', yScale(value))
                    .attr('r', 3)
                    .attr('fill', config.colors.alternatives)
                    .attr('opacity', config.alternativeOpacity)
                    .attr('stroke', 'white')
                    .attr('stroke-width', 0.5);
            });
            
            // Add axes
            g.append('g')
                .attr('class', 'axis axis-x')
                .attr('transform', `translate(0,${chartHeight})`)
                .call(d3.axisBottom(xScale).ticks(5).tickFormat(d => d === 0 ? '' : `t${d}`));
            
            g.append('g')
                .attr('class', 'axis axis-y')
                .call(d3.axisLeft(yScale).ticks(5).tickFormat(d => d.toFixed(0)));
            
            // Add hover interaction
            chartDiv.on('mouseenter', function() {
                alternativesGroup.transition()
                    .duration(300)
                    .style('opacity', 1);
            }).on('mouseleave', function() {
                alternativesGroup.transition()
                    .duration(300)
                    .style('opacity', 0);
            });
        }

        // Load data and initialize visualization
        d3.json('predictions-data.json').then(function(data) {
            const container = document.getElementById('charts-container');
            
            // Calculate global Y scale extent
            let allValues = [];
            
            // Add historical values
            data.historical.forEach(point => {
                allValues.push(point.value);
            });
            
            // Add all predictions
            Object.values(data.cases).forEach(caseData => {
                allValues.push(caseData.aggregation);
                caseData.alternatives.forEach(val => allValues.push(val));
            });
            
            const yExtent = d3.extent(allValues);
            const yPadding = (yExtent[1] - yExtent[0]) * 0.05; // Smaller padding for better use of space
            const globalYScale = [yExtent[0] - yPadding, yExtent[1] + yPadding];
            
            console.log('Global Y Scale:', globalYScale); // Debug log
            
            // Create charts in the correct order (by pattern first, then trend)
            const patterns = ['agreement', 'polarization', 'risk_of_loss', 'chance_of_gain', 'ambiguous_spread'];
            const trends = ['increase', 'decrease', 'stable'];
            
            patterns.forEach(pattern => {
                trends.forEach(trend => {
                    const caseId = `${trend}_${pattern}`;
                    const caseData = {
                        ...data.cases[caseId],
                        historical: data.historical
                    };
                    createChart(container, caseData, globalYScale);
                });
            });
        }).catch(function(error) {
            console.error('Error loading data:', error);
            document.getElementById('charts-container').innerHTML = 
                '<p style="text-align: center; color: red;">Error loading data. Please ensure predictions-data.json exists.</p>';
        });
    </script>
</body>
</html>